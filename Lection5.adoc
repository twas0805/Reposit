:toc: macro

include::Titul.adoc[]

toc::[]

== Задачи

Объяснить, что такое ссылки, указатели, какие они бывают, каковы свойства каждого из них.

== Указатели

Указатели – переменная, хранящая адрес другой переменной.

Пример:
[source,cpp]
----
int main() 
{
  int  i = 0; # (1)
  int* ptr_i = &i; # (2)
  *ptr_i = 7; # (3)
  return 0;
}
----

. В данном случае мы создали переменную _i_ типа int и указатель _ptr_i_ на эту переменную i.

. (Тип данных*) означает объявление указателя, _&_ перед переменной i означает взятие адреса.

. * перед указателем означает – разыменовывае указателя, в данном случае мы записали значение 7, в переменную по адресу, который лежит в ptr_i, то есть в i.

К указателю можно прибавлять числа или отнимать или сравнивать с другим, если прибавить 1 к нему, то он будет менять адрес на величину, равную размеру типа данных указателя.

Указателем является и массив, он указывает на первый элемент. Массив – последовательность объектов одного типа, занимающего непрерывную область памяти. То есть массив типа int размером 4 лежит по адресу 0x02000780, значит его следующий элемент будет лежать по адресу (0x02000780 + 4) и так далее, до его конца 0x02000790. 

Пример:
[source,cpp]
----
int main() 
{
  int  arr[] = {0,1,2,3} ;      # (1)
  int* ptr = arr ;              # (2)
  ptr ++ ;                      # (3)
  int a = *(ptr + 3) ;          # (4)
}
----

. Объявление массива размером 4.

. Обявление указателя на массив, для выполнения операций над указателем.

. Увеличение указателя на 1. Смещение адреса на 4 байта. Сейчас переменная указатель ptr стал указывать на второй элемент массива.

. Объявляем переменную _а_ типа int и присваиваем ей значение аrr[3].

Работа с указателями может быть опасна.

Пример:
[source,cpp]
----
int main() 
{
  int  arr[] = {1,2,3,4};
  int a = 9;
  int* ptr = arr;
  for(int i=0; i<=4; i++)
  {
    *ptr = i;
    ptr++;
  }
}
----

В данном случае мы ошиблись и указали в цикле *i<=4* и из-за этого, когда перебор массива закончится, мы выйдем за его границы, перейдём по адресу, который не связан с элементами массива, и если не повезёт, то _a_ станет равной 4, если она будет иметь адрес, следующий за arr[3].

Для того, чтобы сделать работу с ними более безопасной, можно использовать константный указатель и указатель на константу.

Константный указатель – это указатель, адрес которого нельзя поменять.

Указатель на константу – это указатель, адрес которого можно менять, но нельзя изменить значение переменной, на которую он указывает.

Так же их можно объединить и это будет называться константый указатель на константу, его адрес и значение переменной, которой он содержит, нельзя изменить.

Пример:
[source,cpp]
----
int main() 
{
  const int i = 0;
  const int* ptr_c = &i; #(1)
  int a = 0;
  int* const c_ptr = &a; #(2) 
  const int* const c_ptr_c = &a; #(3)
}
----

. Создание указателя на константу.

. Создание константного указателя.

. Создание константного указателя на константу.

== Ссылки

Ссылка – псевдоним переменной.

. Если применить оператор взятия адреса к ссылке, то будет выведен адрес переменной, на которую она ссылается.

. Ссылка похожа на констатный указатель.

. Ссылки нельзя сравнивать.

. Ссылка не может быть не проинициализирована.

Пример:
[source,cpp]
----
int main()
{
  int a = 0;
  int &ref = a;     # (1)
  ref = 5;          # (2)
  return 0 ;
}
----

. Определение ссылки происходит знаком _&_ перед переменной.

. Присваивание переменной _a_ числа 5.

== Выводы

В данной работе было проведено изучение ссылок и их свойств,указателей, в том числе констатных указателей, указателей на константу и констатных указателей на константу.