:toc: macro

include::Titul_Lection7.adoc[]

toc::[]

== Задачи

Написать как работать с системой фазовой подстройки частоты (ФАПЧ) и подать на модуль тактирования, используя его, 32 МГц, исходный сигнал идет от внутреннего высокочастотного RC-генератора 16 МГц. Дать определение следующим операторам: унарный плюс, запятая.

== Операторы

=== Унарный плюс

Результатом унарного оператора плюса (+) является значение его операнда. Так же если операнд имеет тип char и к нему применить унарный плюс, то операнд приведётся к типу int и будет иметь значение, связанное с кодом символа из таблицы ASCII. Это называется IntegerPromotion, то есть оператор расширяет тип до типа Int. Такое же поведение кстати и для других унарных операторов - и ~ вообще, вот для такого случая:
char a, b; char c = a+b;
тоже будет выполнятся Integer promotion для результата a+b, но потом он обрежется до типа char.

Пример:

[source,cpp]
----
#include "rccregisters.hpp"

int main()
{
  char ch = 'q';
  char a = 'q', b = 'q';
  char c = a+b;
  std::cout << ch << std::endl;
  std::cout << c << std::endl;
  std::cout << +c << std::endl;
  return 1;

----

В данном случае было получен код символа "q" из таблицы.

.Таблица ASCII
image::IMG/Table_ASCII.jpg[]

.Результат работы программы
image::IMG/Result(+).jpg[]

=== Запятая

Оператор запятая (,) позволяет вычислять несколько выражений везде, где разрешено одно выражение. Оператор запятая вычисляет левый операнд, затем правый операнд, а затем возвращает результат правого операнда.

Примеры:

[source,cpp]
----
int main()
{
  int a, b, c;  #(1)
  c = (a = 5, b = 4);  #(2)
  std::cout << c << std::endl;
  c = (std::cout << "Определяю переменную" << std::endl , 10) #(3)
  std::cout << c << std::endl;
  return 1;
}
----

. Определели несколько переменных одного типа, используя оператор запятая (,).

. Сначала присвоили значение переменной "a", затем значение переменной "b", так как переменная "b" находилась правее, то её значение присвоилось переменной "c".

. Сначала выведется сообщение, а затем "c" присвоится 10.

.Результат работы программы (,)
image::IMG/Result(,).jpg[]

Если бы скобок не было, то значение "с" было бы равно 5.

== Фазовая подстройка частоты

Система ФАПЧ (PLL) – набор из умножителей и делителей,исходный сигнал он получает от HSI или HSE, а на выходе у него уже другая частота.​

Регистр имеет поля различной длины PLLM (2 ≤ PLLM ≤ 63), PLLN ( 50 ≤ PLLN ≤ 432), PLLP (PLLP = 2, 4, 6, or 8),
PLLQ (2 ≤ PLLQ ≤ 15). Так же есть поле PLLSRC, оно отвечает за то, с какого генератора будет подаваться входной сигнал.

Для подачи на модуль тактирования соответсвующей частоты, в данном случае 32 МГц, нужно использовать поля PLLM, PLLN, PLLP. PLLQ нужен для подачи частоты для интерфейса USB.

Формула, по которой расчитывается системная тактовая частота с изпользованием ФАПЧ:

[stem]
++++
f = f(PLL clock input) × (PLLN / PLLM) / PLLP​
++++

Используя данную формулу, нужно подобрать только соответствующие коэффициенты. Можно взять следующие коэффициенты: PLLN = 128, PLLM = 8, PLLP = 8.

.main.c

[source,cpp]
----
#include "rccregisters.hpp" // for RCC
#include "gpioaregisters.hpp" // for GPIOA
#include "gpiocregisters.hpp" // for GPION

std::uint32_t SystemCoreClock = 16'000'000U;

extern "C" {
int __low_level_init(void)
{
  // Включение внутреннего генератора
  RCC::CR::HSION::On::Set();
  // Ожидание пока внутренний генератор не будет готов
  while (RCC::CR::HSIRDY::NotReady::IsSet())
  {

  }
  
  // Сброс всех битов в 0 на всякий случай
  *reinterpret_cast<std::uint32_t*>(0x40023804) &= 0;
  // Включение тактирования от внутреннего высокочастотного генератора
  RCC::PLLCFGR::PLLSRC::HsiSource::Set();
  // Операция, при которой PLLP стало равно 8
  *reinterpret_cast<std::uint32_t*>(0x40023804) |= (1U << 16U);
  *reinterpret_cast<std::uint32_t*>(0x40023804) |= (1U << 17U);
  // Операция, при которой PLLM стало равно 8
  *reinterpret_cast<std::uint32_t*>(0x40023804) |= (1U << 3U);
  // Операция, при которой PLLN стало равно 128
  *reinterpret_cast<std::uint32_t*>(0x40023804) |= (1U << 13U);
  // Включение ФАПЧ
  RCC::CR::PLLON::On::Set();
  // Ожидание пока внутренний генератор не будет готов
  while (RCC::CR::PLLRDY::Unclocked::IsSet())
  {
    
  }
  // Выбор на коммутататоре сигнала с ФАПЧ
  RCC::CFGR::SW::Pll::Set();
  // Ожидание пока коммутатор не будет готов
  while (!RCC::CFGR::SWS::Pll::IsSet())
  {
    
  }
  RCC::CR::HSION::Off::Set();
  RCC::APB2ENR::SYSCFGEN::Enable::Set();

  return 1;
}
}

void delay(int cycles)
{
  for(int i = 0; i < cycles; ++i)    
  {   
    asm volatile("");
  }    
}

int main()
{
  RCC::AHB1ENR::GPIOCEN::Enable::Set();
  GPIOC::MODER::MODER5::Output::Set();
  GPIOC::MODER::MODER8::Output::Set();

  for(;;)
  {
     GPIOC::ODR::ODR5::High::Set();
     delay(1000000); 
     GPIOC::ODR::ODR5::Low::Set();
     delay(1000000); 
  }
  
  return 1;
}
----

.Работа кода
video::Video/Result_PLL.mov[]

== Выводы

В данной работе было дано описание таким операторам, как унарный плюс и запятая, а также приведены примеры работы с ними. Дано описание фазовой подстройки частоты, как с ним работать, и написан код, который формирует системную тактовую частоту в 32 МГц, с исходным сигналом от внутреннего высокочастотного генератора. 